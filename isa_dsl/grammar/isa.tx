// ISA DSL Grammar for textX
// Using skipws to handle whitespace

// Root rule: can be either a full architecture spec or a partial spec
// Try ISASpecFull first (more specific - starts with 'architecture')
ISASpec:
    ISASpecFull | ISASpecPartial
;

// Full ISA specification with architecture block
// All blocks are optional since they can be provided by included files
ISASpecFull:
    'architecture' name=ID '{'
        (properties*=Property)*
        (registers=RegisterBlock)?
        (formats=FormatBlock)?
        (instructions=InstructionBlock)?
    '}'
;

// Partial ISA specification for included files - all blocks are optional
ISASpecPartial:
    (properties*=Property)*
    (registers=RegisterBlock)?
    (formats=FormatBlock)?
    (instructions=InstructionBlock)?
;

Property:
    name=ID ':' value=PropertyValue
;

PropertyValue:
    INT | STRING | ID | BOOL
;

BOOL:
    'True' | 'False' | 'true' | 'false'
;

RegisterBlock:
    'registers' '{'
        (virtual_registers+=VirtualRegister | aliases+=RegisterAlias | registers+=Register)*
    '}'
;

Register:
    type=RegisterType name=ID width=INT ('[' count=INT ']')? (vector_props=VectorProperties)? ('{'
        fields+=RegisterField
    '}')?
;

VirtualRegister:
    'virtual' 'register' name=ID width=INT '=' '{' components=VirtualRegisterComponents '}'
;

VirtualRegisterComponents:
    first=VirtualRegisterComponent ('|' rest+=VirtualRegisterComponent)*
;

VirtualRegisterComponent:
    indexed_register=IndexedRegister | simple_register=ID
;

IndexedRegister:
    reg_name=ID '[' index=INT ']'
;

RegisterAlias:
    'alias' alias_name=ID '=' target=RegisterReference
;

RegisterReference:
    indexed_target=IndexedRegister | simple_target=ID
;

VectorProperties:
    '<' element_width=INT ',' lanes=INT '>'
;

RegisterType:
    'gpr' | 'sfr' | 'vec'
;

RegisterField:
    name=ID ':' '[' lsb=INT ':' msb=INT ']'
;

FormatBlock:
    'formats' '{'
        (formats+=InstructionFormat | bundle_formats+=BundleFormat)*
    '}'
;

InstructionFormat:
    'format' name=ID width=INT '{'
        fields+=FormatField
        ('identification_fields' ':' identification_fields=IdentificationFieldList)?
    '}'
;

BundleFormat:
    'bundle' 'format' name=ID width=INT '{'
        ('instruction_start' ':' instruction_start=INT)?
        ('identification_fields' ':' identification_fields=IdentificationFieldList)?
        slots+=BundleSlot
    '}'
;

BundleSlot:
    slot_name=ID ':' '[' lsb=INT ':' msb=INT ']'
;

FormatField:
    name=ID ':' '[' lsb=INT ':' msb=INT ']'
;

InstructionBlock:
    'instructions' '{'
        (instructions+=Instruction | instruction_aliases+=InstructionAlias)*
    '}'
;

InstructionAlias:
    'alias' 'instruction' alias_mnemonic=ID '=' target_mnemonic=ID ('{' ('assembly_syntax' ':' assembly_syntax=STRING)? '}')?
;

Instruction:
    'instruction' mnemonic=ID '{'
        ('format' ':' format=[InstructionFormat])?
        ('bundle_format' ':' bundle_format=[BundleFormat])?
        ('encoding' ':' encoding=EncodingSpec)?
        ('operands' ':' operands_list=OperandList)?
        ('assembly_syntax' ':' assembly_syntax=STRING)?
        ('behavior' ':' behavior=RTLBlock)?
        ('external_behavior' ':' external_behavior=BOOL)?
    '}'
;

OperandList:
    first=OperandSpec (',' rest=OperandList)?
;

OperandSpec:
    distributed_operand=DistributedOperand | simple_operand=ID
;

DistributedOperand:
    name=ID '(' field_list=FieldList ')'
;

FieldList:
    first=ID (',' rest+=ID)*
;

IdentificationFieldList:
    first=ID (',' rest+=ID)*
;

EncodingSpec:
    '{' assignments+=EncodingAssignment (',' assignments+=EncodingAssignment)* '}'
;

EncodingAssignment:
    field=ID '=' value=EncodingValue
;

EncodingValue:
    hex_value=HEX | int_value=INT
;

RTLBlock:
    '{' statements+=RTLStatement+ '}'
;

RTLStatement:
    RTLAssignment | RTLConditional | RTLMemoryAccess | RTLForLoop
;

RTLAssignment:
    target=RTLLValue '=' expr=RTLExpression ';'
;

RTLConditional:
    'if' '(' condition=RTLExpression ')' '{' then_statements+=RTLStatement '}' ('else' '{' else_statements+=RTLStatement '}')?
;

RTLMemoryAccess:
    memory_access=RTLLValue '=' 'MEM' '[' address=RTLExpression ']' ';' |
    'MEM' '[' address=RTLExpression ']' '=' value=RTLExpression ';'
;

RTLForLoop:
    'for' '(' init=RTLAssignment condition=RTLExpression ';' update=RTLAssignment ')' '{' statements+=RTLStatement+ '}'
;

RTLExpression:
    RTLTernary | RTLBinaryOp | RTLUnaryOp | RTLFunctionCall | RTLExpressionAtom
;

RTLExpressionAtom:
    RTLLValue | RTLConstant | OperandReference | RTLBitfieldAccess | '(' RTLExpression ')'
;

OperandReference:
    name=ID | index=INT
;

RTLTernary:
    condition=RTLExpressionAtom '?' then_expr=RTLExpression ':' else_expr=RTLExpression
;

RTLBinaryOp:
    left=RTLExpressionAtom op=BinaryOperator right=RTLExpression
;

BinaryOperator:
    '<<' | '>>' | '<=' | '>=' | '==' | '!=' | '<' | '>' | '+' | '-' | '*' | '/' | '%' | '&' | '|' | '^'
;

RTLUnaryOp:
    op=UnaryOperator expr=RTLExpressionAtom
;

UnaryOperator:
    '-' | '!' | '~'
;

RTLLValue:
    register_access=RegisterAccess | field_access=FieldAccess | simple_register=ID | variable=ID
;

RegisterAccess:
    reg_name=ID '[' index=OperandReference ']' (lane_access=LaneAccess)?
;

LaneAccess:
    '[' lane_index=LaneIndex ']'
;

LaneIndex:
    OperandReference | RTLConstant | ID
;

FieldAccess:
    reg_name=ID '.' field_name=ID
;

RTLConstant:
    hex_value=HEX | binary_value=BINARY | value=INT
;

RTLBitfieldBase:
    RTLLValue | RTLConstant | OperandReference
;

RTLBitfieldAccess:
    base=RTLBitfieldBase '[' msb=RTLExpression ':' lsb=RTLExpression ']'
;

RTLFunctionCall:
    function_name=ID '(' (args+=RTLExpression (',' args+=RTLExpression)*)? ')'
;

HEX:
    /0[xX][0-9a-fA-F]+/
;

BINARY:
    /0[bB][01]+/
;

