architecture AliasesISA {
    word_size: 32
    endianness: little
    
    registers {
        gpr R 32 [16]
        sfr PC 32
        sfr HIGH 32
        sfr LOW 32
        
        virtual register E 64 = {R[0]|R[1]}
        virtual register E2 64 = {R[2]|R[3]}
        virtual register WIDE 64 = {HIGH|LOW}
        
        alias SP = R[13]
        alias LR = R[14]
        alias PC_ALIAS = PC
    }
    
    formats {
        format R_TYPE 32 {
            opcode: [28:31]
            rd: [24:27]
            rs1: [20:23]
            rs2: [16:19]
            func: [0:15]
        }
    }
    
    instructions {
        instruction ADD {
            format: R_TYPE
            encoding: { opcode=0 }
            operands: rd, rs1, rs2
            assembly_syntax: "ADD R{rd}, R{rs1}, R{rs2}"
            behavior: {
                R[rd] = R[rs1] + R[rs2];
            }
        }
        
        instruction STM {
            format: R_TYPE
            encoding: { opcode=1 }
            operands: rd, rs1
            assembly_syntax: "STM R{rd}, R{rs1}"
            behavior: {
                MEM[R[rd]] = R[rs1];
            }
        }
        
        instruction LDM {
            format: R_TYPE
            encoding: { opcode=2 }
            operands: rd, rs1
            assembly_syntax: "LDM R{rd}, R{rs1}"
            behavior: {
                R[rd] = MEM[R[rs1]];
            }
        }
        
        alias instruction PUSH = STM {
            assembly_syntax: "PUSH R{rd}"
        }
        
        alias instruction POP = LDM {
            assembly_syntax: "POP R{rd}"
        }
        
        instruction MOV_VREG {
            format: R_TYPE
            encoding: { opcode=3 }
            operands: rd, rs1
            assembly_syntax: "MOV_VREG E{rd}, E{rs1}"
            behavior: {
                R[rd] = R[rs1];
            }
        }
    }
}

