architecture BuiltinsTest {
    word_size: 32
    endianness: little
    
    registers {
        gpr R 32 [16]
        sfr PC 32
    }
    
    formats {
        format R_TYPE 32 {
            opcode: [28:31]
            rd: [24:27]
            rs1: [20:23]
            rs2: [16:19]
            func: [0:15]
        }
    }
    
    instructions {
        // Test byte-wise absolute value calculation and packing
        instruction ABS_BYTES {
            format: R_TYPE
            encoding: { opcode=0, func=1 }
            operands: rd, rs1
            assembly_syntax: "ABS_BYTES R{rd}, R{rs1}"
            behavior: {
                temp3 = extract_bits(R[rs1], 31, 24);
                temp2 = extract_bits(R[rs1], 23, 16);
                temp1 = extract_bits(R[rs1], 15, 8);
                temp0 = extract_bits(R[rs1], 7, 0);
                signed3 = to_signed(temp3, 8);
                signed2 = to_signed(temp2, 8);
                signed1 = to_signed(temp1, 8);
                signed0 = to_signed(temp0, 8);
                abs3 = (signed3 >= 0) ? signed3 : (0 - signed3);
                abs2 = (signed2 >= 0) ? signed2 : (0 - signed2);
                abs1 = (signed1 >= 0) ? signed1 : (0 - signed1);
                abs0 = (signed0 >= 0) ? signed0 : (0 - signed0);
                R[rd] = ((abs3 & 0xFF) << 24) | ((abs2 & 0xFF) << 16) | ((abs1 & 0xFF) << 8) | (abs0 & 0xFF);
            }
        }
        
        // Test extract_bits function: extract bits [15:8] from R[rs1]
        instruction EXTRACT_BITS {
            format: R_TYPE
            encoding: { opcode=1, func=0 }
            operands: rd, rs1
            assembly_syntax: "EXTRACT_BITS R{rd}, R{rs1}"
            behavior: {
                R[rd] = extract_bits(R[rs1], 15, 8);
            }
        }
        
        // Test sign_extend(value, from_bits) - 2 args
        instruction SIGN_EXT_8 {
            format: R_TYPE
            encoding: { opcode=2, func=0 }
            operands: rd, rs1
            assembly_syntax: "SIGN_EXT_8 R{rd}, R{rs1}"
            behavior: {
                temp = extract_bits(R[rs1], 7, 0);
                R[rd] = sign_extend(temp, 8);
            }
        }
        
        // Test sign_extend(value, from_bits, to_bits) - 3 args
        instruction SIGN_EXT_8_TO_16 {
            format: R_TYPE
            encoding: { opcode=3 }
            operands: rd, rs1
            assembly_syntax: "SIGN_EXT_8_TO_16 R{rd}, R{rs1}"
            behavior: {
                temp = extract_bits(R[rs1], 7, 0);
                R[rd] = sign_extend(temp, 8, 16);
            }
        }
        
        // Test zero_extend(value, from_bits) - 2 args
        instruction ZERO_EXT_8 {
            format: R_TYPE
            encoding: { opcode=4 }
            operands: rd, rs1
            assembly_syntax: "ZERO_EXT_8 R{rd}, R{rs1}"
            behavior: {
                temp = extract_bits(R[rs1], 7, 0);
                R[rd] = zero_extend(temp, 8);
            }
        }
        
        // Test zero_extend(value, from_bits, to_bits) - 3 args
        instruction ZERO_EXT_8_TO_16 {
            format: R_TYPE
            encoding: { opcode=5 }
            operands: rd, rs1
            assembly_syntax: "ZERO_EXT_8_TO_16 R{rd}, R{rs1}"
            behavior: {
                temp = extract_bits(R[rs1], 7, 0);
                R[rd] = zero_extend(temp, 8, 16);
            }
        }
        
        // Test extract_bits function
        instruction EXTRACT_BITS_FUNC {
            format: R_TYPE
            encoding: { opcode=6 }
            operands: rd, rs1
            assembly_syntax: "EXTRACT_BITS_FUNC R{rd}, R{rs1}"
            behavior: {
                R[rd] = extract_bits(R[rs1], 23, 16);
            }
        }
        
        // Test bitfield access with sign extension
        instruction BITFIELD_SIGN_EXT {
            format: R_TYPE
            encoding: { opcode=7 }
            operands: rd, rs1
            assembly_syntax: "BITFIELD_SIGN_EXT R{rd}, R{rs1}"
            behavior: {
                temp = extract_bits(R[rs1], 15, 8);
                R[rd] = sign_extend(temp, 8);
            }
        }
        
        // Test sext alias
        instruction SEXT_ALIAS {
            format: R_TYPE
            encoding: { opcode=8 }
            operands: rd, rs1
            assembly_syntax: "SEXT_ALIAS R{rd}, R{rs1}"
            behavior: {
                temp = extract_bits(R[rs1], 7, 0);
                R[rd] = sext(temp, 8);
            }
        }
        
        // Test zext alias
        instruction ZEXT_ALIAS {
            format: R_TYPE
            encoding: { opcode=9 }
            operands: rd, rs1
            assembly_syntax: "ZEXT_ALIAS R{rd}, R{rs1}"
            behavior: {
                temp = extract_bits(R[rs1], 7, 0);
                R[rd] = zext(temp, 8);
            }
        }
        
        // Test to_signed with 8-bit value
        instruction TO_SIGNED_8 {
            format: R_TYPE
            encoding: { opcode=10 }
            operands: rd, rs1
            assembly_syntax: "TO_SIGNED_8 R{rd}, R{rs1}"
            behavior: {
                R[rd] = to_signed(extract_bits(R[rs1], 7, 0), 8);
            }
        }
        
        // Test to_signed with 16-bit value
        instruction TO_SIGNED_16 {
            format: R_TYPE
            encoding: { opcode=11 }
            operands: rd, rs1
            assembly_syntax: "TO_SIGNED_16 R{rd}, R{rs1}"
            behavior: {
                R[rd] = to_signed(extract_bits(R[rs1], 15, 0), 16);
            }
        }
        
        // Test to_unsigned with 8-bit value
        instruction TO_UNSIGNED_8 {
            format: R_TYPE
            encoding: { opcode=12 }
            operands: rd, rs1
            assembly_syntax: "TO_UNSIGNED_8 R{rd}, R{rs1}"
            behavior: {
                R[rd] = to_unsigned(extract_bits(R[rs1], 7, 0), 8);
            }
        }
        
        // Test to_unsigned with 16-bit value
        instruction TO_UNSIGNED_16 {
            format: R_TYPE
            encoding: { opcode=13 }
            operands: rd, rs1
            assembly_syntax: "TO_UNSIGNED_16 R{rd}, R{rs1}"
            behavior: {
                R[rd] = to_unsigned(extract_bits(R[rs1], 15, 0), 16);
            }
        }
        
        // Test to_signed with extract_bits
        instruction TO_SIGNED_EXTRACT {
            format: R_TYPE
            encoding: { opcode=14 }
            operands: rd, rs1
            assembly_syntax: "TO_SIGNED_EXTRACT R{rd}, R{rs1}"
            behavior: {
                temp = extract_bits(R[rs1], 15, 8);
                R[rd] = to_signed(temp, 8);
            }
        }
        
        // Test to_unsigned with extract_bits
        instruction TO_UNSIGNED_EXTRACT {
            format: R_TYPE
            encoding: { opcode=15, func=0 }
            operands: rd, rs1
            assembly_syntax: "TO_UNSIGNED_EXTRACT R{rd}, R{rs1}"
            behavior: {
                temp = extract_bits(R[rs1], 15, 8);
                R[rd] = to_unsigned(temp, 8);
            }
        }
        
        // Test ssov - Signed Saturation on Overflow (32-bit)
        instruction SSOV_32 {
            format: R_TYPE
            encoding: { opcode=0, func=2 }
            operands: rd, rs1
            assembly_syntax: "SSOV_32 R{rd}, R{rs1}"
            behavior: {
                R[rd] = ssov(R[rs1], 32);
            }
        }
        
        // Test ssov - Signed Saturation on Overflow (16-bit)
        instruction SSOV_16 {
            format: R_TYPE
            encoding: { opcode=0, func=3 }
            operands: rd, rs1
            assembly_syntax: "SSOV_16 R{rd}, R{rs1}"
            behavior: {
                R[rd] = ssov(R[rs1], 16);
            }
        }
        
        // Test suov - Unsigned Saturation on Overflow (32-bit)
        instruction SUOV_32 {
            format: R_TYPE
            encoding: { opcode=0, func=4 }
            operands: rd, rs1
            assembly_syntax: "SUOV_32 R{rd}, R{rs1}"
            behavior: {
                R[rd] = suov(R[rs1], 32);
            }
        }
        
        // Test suov - Unsigned Saturation on Overflow (16-bit)
        instruction SUOV_16 {
            format: R_TYPE
            encoding: { opcode=0, func=5 }
            operands: rd, rs1
            assembly_syntax: "SUOV_16 R{rd}, R{rs1}"
            behavior: {
                R[rd] = suov(R[rs1], 16);
            }
        }
        
        // Test carry - Calculate Carry Out
        instruction CARRY {
            format: R_TYPE
            encoding: { opcode=0, func=6 }
            operands: rd, rs1, rs2
            assembly_syntax: "CARRY R{rd}, R{rs1}, R{rs2}"
            behavior: {
                temp = R[rs1] + R[rs2];
                R[rd] = carry(R[rs1], R[rs2], 0);
            }
        }
        
        // Test carry with carry_in
        instruction CARRY_WITH_CIN {
            format: R_TYPE
            encoding: { opcode=0, func=7 }
            operands: rd, rs1, rs2
            assembly_syntax: "CARRY_WITH_CIN R{rd}, R{rs1}, R{rs2}"
            behavior: {
                R[rd] = carry(R[rs1], R[rs2], 1);
            }
        }
        
        // Test borrow - Calculate Borrow Out
        instruction BORROW {
            format: R_TYPE
            encoding: { opcode=0, func=8 }
            operands: rd, rs1, rs2
            assembly_syntax: "BORROW R{rd}, R{rs1}, R{rs2}"
            behavior: {
                R[rd] = borrow(R[rs1], R[rs2], 0);
            }
        }
        
        // Test borrow with borrow_in
        instruction BORROW_WITH_BIN {
            format: R_TYPE
            encoding: { opcode=0, func=9 }
            operands: rd, rs1, rs2
            assembly_syntax: "BORROW_WITH_BIN R{rd}, R{rs1}, R{rs2}"
            behavior: {
                R[rd] = borrow(R[rs1], R[rs2], 1);
            }
        }
        
        // Test reverse16 - Reverse 16-bit value
        instruction REVERSE16 {
            format: R_TYPE
            encoding: { opcode=0, func=10 }
            operands: rd, rs1
            assembly_syntax: "REVERSE16 R{rd}, R{rs1}"
            behavior: {
                temp = extract_bits(R[rs1], 15, 0);
                R[rd] = reverse16(temp);
            }
        }
        
        // Test leading_ones - Count Leading Ones
        instruction LEADING_ONES {
            format: R_TYPE
            encoding: { opcode=0, func=11 }
            operands: rd, rs1
            assembly_syntax: "LEADING_ONES R{rd}, R{rs1}"
            behavior: {
                R[rd] = leading_ones(R[rs1]);
            }
        }
        
        // Test leading_zeros - Count Leading Zeros
        instruction LEADING_ZEROS {
            format: R_TYPE
            encoding: { opcode=0, func=12 }
            operands: rd, rs1
            assembly_syntax: "LEADING_ZEROS R{rd}, R{rs1}"
            behavior: {
                R[rd] = leading_zeros(R[rs1]);
            }
        }
        
        // Test leading_signs - Count Leading Sign Bits
        instruction LEADING_SIGNS {
            format: R_TYPE
            encoding: { opcode=0, func=13 }
            operands: rd, rs1
            assembly_syntax: "LEADING_SIGNS R{rd}, R{rs1}"
            behavior: {
                R[rd] = leading_signs(R[rs1]);
            }
        }
        
    }
}
