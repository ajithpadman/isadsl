architecture AdvancedRISC {
    word_size: 32
    endianness: little
    
    registers {
        gpr R 32 [16]
        gpr F 32 [32]
        sfr PC 32
        sfr SP 32
        sfr FLAGS 32 {
            Z: [0:0]
            C: [1:1]
            N: [2:2]
            V: [3:3]
            I: [4:4]
        }
        sfr STATUS 32 {
            MODE: [0:1]
            PRIV: [2:2]
        }
    }
    
    formats {
        format R_TYPE 32 {
            opcode: [0:5]
            rd: [6:9]
            rs1: [10:13]
            rs2: [14:17]
            funct: [18:23]
            shamt: [24:28]
            unused: [29:31]
        }
        
        format I_TYPE 32 {
            opcode: [0:5]
            rd: [6:9]
            rs1: [10:13]
            imm: [14:31]
        }
        
        format S_TYPE 32 {
            opcode: [0:5]
            rs1: [6:9]
            rs2: [10:13]
            imm: [14:31]
        }
        
        format B_TYPE 32 {
            opcode: [0:5]
            rs1: [6:9]
            rs2: [10:13]
            imm: [14:31]
        }
        
        format U_TYPE 32 {
            opcode: [0:5]
            rd: [6:9]
            imm: [10:31]
        }
        
        format J_TYPE 32 {
            opcode: [0:5]
            rd: [6:9]
            imm: [10:31]
        }
    }
    
    instructions {
        instruction ADD {
            format: R_TYPE
            encoding: { opcode=0, funct=0 }
            operands: rd, rs1, rs2
            operands: imm
            behavior: {
                R[rd] = R[rs1] + R[rs2];
                FLAGS.Z = (R[rd] == 0) ? 1 : 0;
                FLAGS.C = (R[rd] < R[rs1]) ? 1 : 0;
                FLAGS.N = (R[rd] < 0) ? 1 : 0;
                FLAGS.V = 0;
            }
        }
        
        instruction SUB {
            format: R_TYPE
            encoding: { opcode=0, funct=1 }
            operands: rd, rs1, rs2
            behavior: {
                R[rd] = R[rs1] - R[rs2];
                FLAGS.Z = (R[rd] == 0) ? 1 : 0;
                FLAGS.C = (R[rs1] >= R[rs2]) ? 1 : 0;
                FLAGS.N = (R[rd] < 0) ? 1 : 0;
                FLAGS.V = 0;
            }
        }
        
        instruction SLL {
            format: R_TYPE
            encoding: { opcode=0, funct=2 }
            behavior: {
                R[rd] = R[rs1] << shamt;
            }
            operands: rd, rs1, shamt

        }
        
        instruction SRL {
            format: R_TYPE
            encoding: { opcode=0, funct=3 }
            behavior: {
                R[rd] = R[rs1] >> shamt;
            }
            operands: rd, rs1, shamt

        }
        
        instruction AND {
            format: R_TYPE
            encoding: { opcode=0, funct=4 }
            behavior: {
                R[rd] = R[rs1] & R[rs2];
                FLAGS.Z = (R[rd] == 0) ? 1 : 0;
            }
            operands: rd, rs1, rs2

        }
        
        instruction OR {
            format: R_TYPE
            encoding: { opcode=0, funct=5 }
            behavior: {
                R[rd] = R[rs1] | R[rs2];
                FLAGS.Z = (R[rd] == 0) ? 1 : 0;
            }
            operands: rd, rs1, rs2

        }
        
        instruction XOR {
            format: R_TYPE
            encoding: { opcode=0, funct=6 }
            behavior: {
                R[rd] = R[rs1] ^ R[rs2];
                FLAGS.Z = (R[rd] == 0) ? 1 : 0;
            }
            operands: rd, rs1, rs2

        }
        
        instruction ADDI {
            format: I_TYPE
            encoding: { opcode=1 }
            behavior: {
                R[rd] = R[rs1] + imm;
                FLAGS.Z = (R[rd] == 0) ? 1 : 0;
                FLAGS.N = (R[rd] < 0) ? 1 : 0;
            }
            operands: rd, rs1, imm

        }
        
        instruction SLTI {
            format: I_TYPE
            encoding: { opcode=2 }
            behavior: {
                R[rd] = (R[rs1] < imm) ? 1 : 0;
            }
            operands: rd, rs1, imm

        }
        
        instruction LOAD {
            format: I_TYPE
            encoding: { opcode=3 }
            behavior: {
                R[rd] = MEM[R[rs1] + imm];
            }
            operands: rd, rs1, imm

        }
        
        instruction STORE {
            format: S_TYPE
            encoding: { opcode=4 }
            behavior: {
                MEM[R[rs1] + imm] = R[rs2];
            }
            operands: rs1, rs2, imm

        }
        
        instruction BEQ {
            format: B_TYPE
            encoding: { opcode=5 }
            behavior: {
                if (R[rs1] == R[rs2]) {
                    PC = PC + (imm << 2);
                }
            }
            operands: rs1, rs2, imm
        }
        
        instruction BNE {
            format: B_TYPE
            encoding: { opcode=6 }
            behavior: {
                if (R[rs1] != R[rs2]) {
                    PC = PC + (imm << 2);
                }
            }
            operands: rs1, rs2, imm
        }
        
        instruction BLT {
            format: B_TYPE
            encoding: { opcode=7 }
            behavior: {
                if (R[rs1] < R[rs2]) {
                    PC = PC + (imm << 2);
                }
            }
            operands: rs1, rs2, imm
        }
        
        instruction BGE {
            format: B_TYPE
            encoding: { opcode=8 }
            behavior: {
                if (R[rs1] >= R[rs2]) {
                    PC = PC + (imm << 2);
                }
            }
            operands: rs1, rs2, imm
        }
        
        instruction LUI {
            format: U_TYPE
            encoding: { opcode=9 }
            behavior: {
                R[rd] = imm << 12;
            }
            operands: rd, imm

        }
        
        instruction AUIPC {
            format: U_TYPE
            encoding: { opcode=10 }
            behavior: {
                R[rd] = PC + (imm << 12);
            }
            operands: rd, imm

        }
        
        instruction JAL {
            format: J_TYPE
            encoding: { opcode=11 }
            behavior: {
                R[rd] = PC + 4;
                PC = PC + (imm << 2);
            }
            operands: rd, imm

        }
        
        instruction JALR {
            format: I_TYPE
            encoding: { opcode=12 }
            behavior: {
                R[rd] = PC + 4;
                PC = (R[rs1] + imm) & 4294967294;
            }
            operands: rd, rs1, imm

        }
        
        instruction PUSH {
            format: I_TYPE
            encoding: { opcode=13 }
            behavior: {
                SP = SP - 4;
                MEM[SP] = R[rs1];
            }
            operands: rs1, imm

        }
        
        instruction POP {
            format: I_TYPE
            encoding: { opcode=14 }
            behavior: {
                R[rd] = MEM[SP];
                SP = SP + 4;
            }
            operands: rd, imm

        }
        
        instruction CALL {
            format: I_TYPE
            encoding: { opcode=15 }
            behavior: {
                SP = SP - 4;
                MEM[SP] = PC + 4;
                PC = PC + (imm << 2);
            }

        }
        
        instruction RET {
            format: R_TYPE
            encoding: { opcode=16, funct=0 }
            behavior: {
                PC = R[rs1];
            }
}

