architecture SIMDRISC {
    word_size: 32
    endianness: little
    
    registers {
        gpr R 32 [16]
        vec V 128 <32, 4>
        sfr PC 32
        sfr FLAGS 32 {
            Z: [0:0]
            V: [1:1]
        }
    }
    
    formats {
        format VV_TYPE 32 {
            opcode: [0:5]
            vd: [6:9]
            vs1: [10:13]
            vs2: [14:17]
            funct: [18:23]
            unused: [24:31]
        }
        
        format VS_TYPE 32 {
            opcode: [0:5]
            vd: [6:9]
            vs1: [10:13]
            rs2: [14:17]
            funct: [18:23]
            unused: [24:31]
        }
        
        format VI_TYPE 32 {
            opcode: [0:5]
            vd: [6:9]
            vs1: [10:13]
            imm: [14:31]
        }
    }
    
    instructions {
        instruction VADD {
            format: VV_TYPE
            encoding: { opcode=32, funct=0 }
            operands: vd, vs1, vs2
            behavior: {
                V[vd][0] = V[vs1][0] + V[vs2][0];
                V[vd][1] = V[vs1][1] + V[vs2][1];
                V[vd][2] = V[vs1][2] + V[vs2][2];
                V[vd][3] = V[vs1][3] + V[vs2][3];
            }
        }
        
        instruction VSUB {
            format: VV_TYPE
            encoding: { opcode=32, funct=1 }
            operands: vd, vs1, vs2
            behavior: {
                V[vd][0] = V[vs1][0] - V[vs2][0];
                V[vd][1] = V[vs1][1] - V[vs2][1];
                V[vd][2] = V[vs1][2] - V[vs2][2];
                V[vd][3] = V[vs1][3] - V[vs2][3];
            }
        }
        
        instruction VMUL {
            format: VV_TYPE
            encoding: { opcode=32, funct=2 }
            operands: vd, vs1, vs2
            behavior: {
                V[vd][0] = V[vs1][0] * V[vs2][0];
                V[vd][1] = V[vs1][1] * V[vs2][1];
                V[vd][2] = V[vs1][2] * V[vs2][2];
                V[vd][3] = V[vs1][3] * V[vs2][3];
            }
        }
        
        instruction VADD_SCALAR {
            format: VS_TYPE
            encoding: { opcode=33, funct=0 }
            operands: vd, vs1, rs2
            behavior: {
                V[vd][0] = V[vs1][0] + R[rs2];
                V[vd][1] = V[vs1][1] + R[rs2];
                V[vd][2] = V[vs1][2] + R[rs2];
                V[vd][3] = V[vs1][3] + R[rs2];
            }
        }
        
        instruction VMUL_SCALAR {
            format: VS_TYPE
            encoding: { opcode=33, funct=1 }
            operands: vd, vs1, rs2
            behavior: {
                V[vd][0] = V[vs1][0] * R[rs2];
                V[vd][1] = V[vs1][1] * R[rs2];
                V[vd][2] = V[vs1][2] * R[rs2];
                V[vd][3] = V[vs1][3] * R[rs2];
            }
        }
        
        instruction VADD_IMM {
            format: VI_TYPE
            encoding: { opcode=34 }
            operands: vd, vs1, imm
            behavior: {
                V[vd][0] = V[vs1][0] + imm;
                V[vd][1] = V[vs1][1] + imm;
                V[vd][2] = V[vs1][2] + imm;
                V[vd][3] = V[vs1][3] + imm;
            }
        }
        
        instruction VLOAD {
            format: VI_TYPE
            encoding: { opcode=35 }
            operands: vd, vs1, imm
            behavior: {
                V[vd][0] = MEM[R[vs1] + imm + 0];
                V[vd][1] = MEM[R[vs1] + imm + 4];
                V[vd][2] = MEM[R[vs1] + imm + 8];
                V[vd][3] = MEM[R[vs1] + imm + 12];
            }
        }
        
        instruction VSTORE {
            format: VI_TYPE
            encoding: { opcode=36 }
            operands: vd, vs1, imm
            behavior: {
                MEM[R[vs1] + imm + 0] = V[vd][0];
                MEM[R[vs1] + imm + 4] = V[vd][1];
                MEM[R[vs1] + imm + 8] = V[vd][2];
                MEM[R[vs1] + imm + 12] = V[vd][3];
            }
        }
        
        instruction VDOT {
            format: VV_TYPE
            encoding: { opcode=32, funct=8 }
            operands: vd, vs1, vs2
            behavior: {
                R[vd] = 0;
                R[vd] = R[vd] + (V[vs1][0] * V[vs2][0]);
                R[vd] = R[vd] + (V[vs1][1] * V[vs2][1]);
                R[vd] = R[vd] + (V[vs1][2] * V[vs2][2]);
                R[vd] = R[vd] + (V[vs1][3] * V[vs2][3]);
            }
        }
        
        instruction VMAX {
            format: VV_TYPE
            encoding: { opcode=32, funct=9 }
            operands: vd, vs1, vs2
            behavior: {
                V[vd][0] = (V[vs1][0] > V[vs2][0]) ? V[vs1][0] : V[vs2][0];
                V[vd][1] = (V[vs1][1] > V[vs2][1]) ? V[vs1][1] : V[vs2][1];
                V[vd][2] = (V[vs1][2] > V[vs2][2]) ? V[vs1][2] : V[vs2][2];
                V[vd][3] = (V[vs1][3] > V[vs2][3]) ? V[vs1][3] : V[vs2][3];
            }
        }
        
        instruction VMIN {
            format: VV_TYPE
            encoding: { opcode=32, funct=10 }
            operands: vd, vs1, vs2
            behavior: {
                V[vd][0] = (V[vs1][0] < V[vs2][0]) ? V[vs1][0] : V[vs2][0];
                V[vd][1] = (V[vs1][1] < V[vs2][1]) ? V[vs1][1] : V[vs2][1];
                V[vd][2] = (V[vs1][2] < V[vs2][2]) ? V[vs1][2] : V[vs2][2];
                V[vd][3] = (V[vs1][3] < V[vs2][3]) ? V[vs1][3] : V[vs2][3];
            }
        }
    }
}

